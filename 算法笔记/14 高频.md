#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

![image-20211201193139938](Untitled.assets/image-20211201193139938.png)

<img src="Untitled.assets/image-20211201193222094.png" alt="image-20211201193222094" style="zoom:50%;" />

Queue = key {2, 1} queue从前到后,2insert放到前面

如果get(1), 相当于用了1, Queue = key {1, 2} 

Put(3, 3) 会把2挤掉, Queue = key {3, 1}

Put(4, 4)  Queue = key {4, 3}

Get(3) Queue = key {3, 4} //将3更新到队列左边入口

如果要实现0(1)时间复杂度必须有hashmap + double LinkedList 头尾都有控制,从前往后加数据,**从尾巴drop数据**, 从头add. 

<img src="14%20%E9%AB%98%E9%A2%91.assets/image-20211202104709966.png" alt="image-20211202104709966" style="zoom:50%;" />

```java
https://www.bilibili.com/video/BV1hp4y1x7MH/?spm_id_from=333.788.recommend_more_video.-1
 //	ListNode 插入和删除的时间复杂度o(1) 
//HashMap查找时间复杂度o(1)

class LRUCache {
        DoubleLinkedNode head;
        DoubleLinkedNode tail;
        Map<Integer, DoubleLinkedNode> map;
        int size;
        public LRUCache(int capacity) {
            head = new DoubleLinkedNode(0, 0);
            tail = new DoubleLinkedNode(0, 0);
            head.next = tail;
            tail.prev = head;
            map = new HashMap<>();
            size = capacity;
        }

        public int get(int key) {
            if (map.containsKey(key)) {
                DoubleLinkedNode cur = map.get(key);
                delete(cur);
                add(cur);
                return cur.val;
            } else {
                return -1;
            }
        }
        private void delete(DoubleLinkedNode node) {
            DoubleLinkedNode prev = node.prev;
            DoubleLinkedNode next = node.next;
            prev.next = next;
            next.prev = prev;
            map.remove(node.key);
        }

        private void add(DoubleLinkedNode node) {
            DoubleLinkedNode oldFirst = head.next;
            head.next = node;
            node.next = oldFirst;
            oldFirst.prev = node;
            node.prev = head;
            map.put(node.key, node);
            if (map.size() > size) {
                DoubleLinkedNode toBeDelete = tail.prev;
                delete(toBeDelete);
            }
        }

        public void put(int key, int value) {
            if (map.containsKey(key)) {
                DoubleLinkedNode curr = map.get(key);
                delete(curr);
                curr.val = value;
                add(curr);
            } else {
                DoubleLinkedNode newNode = new DoubleLinkedNode(key, value);
                add(newNode);
            }
        }

        private class DoubleLinkedNode {
            DoubleLinkedNode prev;
            DoubleLinkedNode next;
            int key;
            int val;
            public DoubleLinkedNode(int key, int val) {
                this.key = key;
                this.val = val;
            }
        }
    }
```

![image-20220313231337746](14%20%E9%AB%98%E9%A2%91.assets/image-20220313231337746.png)



![image-20220313231421155](14%20%E9%AB%98%E9%A2%91.assets/image-20220313231421155.png)

```java
class LinkNode {
    int key;
    int val;
    LinkNode prev;
    LinkNode next;
    public LinkNode(int key, int val) {
        this.key = key;
        this.val = val;
    }
}

public class LRUCache {
    int capacity;
    Map<Integer, LinkNode> map = new HashMap<>();
    LinkNode head = new LinkNode(0, 0);
    LinkNode tail = new LinkNode(0, 0);
    public LRUCache(int capacity) {
        this.capacity = capacity;
        head.next = tail;
        tail.prev = head;
    }
    public int get(int key) {
        if (map.containsKey(key)) {
            LinkNode node = map.get(key);
            moveNodeToTop(node);
            return node.val;
        } else {
            return -1;
        }
    }

    public void put(int key, int value) {
        if (!map.containsKey(key)) {
            if (map.size() == capacity) deleteLastNode();
            LinkNode temp = head.next;
            LinkNode newNode = new LinkNode(key, value);
            head.next = newNode;
            newNode.prev = head;
            newNode.next = temp;
            temp.prev = newNode;
            map.put(key, newNode);
        } else {
            LinkNode node = map.get(key);
            node.val = value;
            moveNodeToTop(node);
        }
    }
    private void deleteLastNode() {
        LinkNode lastNode = tail.prev;
        lastNode.prev.next = tail;
        tail.prev = lastNode.prev;
        map.remove(lastNode.key);
    }
    private void moveNodeToTop(LinkNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        LinkNode temp = head.next;
        head.next = node;
        node.prev = head;
        node.next = temp;
        temp.prev = node;
    }
}
https://www.bilibili.com/video/BV1ZJ411g7ay?from=search&seid=18445679342853574073&spm_id_from=333.337.0.0
```



#### [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

<img src="14%20%E9%AB%98%E9%A2%91.assets/image-20211202105200075.png" alt="image-20211202105200075" style="zoom:50%;" />

```java
class Solution {
        public int countPrimes(int n) {
            int count = 0;
            for (int i = 2; i < n; i++) {
                if (isPrim(i)) {
                    count++;
                }
            }
            return count;
        }
        private boolean isPrim(int n) {
            for (int i = 2; i < n; i++) {
                if (n % i == 0) {
                    return false;
                }
            }
            return true;
        }
    }
```

超时o(n2), 

优化: 

<img src="14%20%E9%AB%98%E9%A2%91.assets/image-20211202120054233.png" alt="image-20211202120054233" style="zoom:50%;" />

```java
class Solution {
    public int countPrimes(int n) {
        boolean[] notPrime = new boolean[n + 1];
        int count = 0;
        for (int i = 2; i < n; i++) {
            if (notPrime[i]) {
                continue;
            }
            count++;
            //找到一个素数时，将能被素数整除的元素去掉
            for (long j = (long) i * i; j < n; j += i) {
                notPrime[(int) j] = true;
            }
        }
        return count;
    }
}
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

ipad笔记

![image-20211203232811811](14%20%E9%AB%98%E9%A2%91.assets/image-20211203232811811.png)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] distance = new int[word1.length() + 1][word2.length() + 1];
        for (int i = 0; i <= word1.length(); i++) {
            for (int j = 0; j <= word2.length(); j++) {
                if (i == 0) {
                    distance[i][j] = j;
                } else if (j == 0) {
                    distance[i][j] = i;
                } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    distance[i][j] = distance[i - 1][j - 1];
                } else {
                    distance[i][j] = Math.min(distance[i - 1][j] + 1, distance[i][j - 1] + 1);
                    distance[i][j] = Math.min(distance[i - 1][j - 1] + 1, distance[i][j]);
                }
            }
        }
        return distance[word1.length()][word2.length()];
    }
}
```

#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

![image-20220119203000069](14%20%E9%AB%98%E9%A2%91.assets/image-20220119203000069.png)

使用hashmap 记录数字和它的最右边边界

![image-20220119202941648](14%20%E9%AB%98%E9%A2%91.assets/image-20220119202941648.png)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        // key表示num，value表示num最远到达的连续右边界
        Map<Integer, Integer> map = new HashMap<>();
        // 初始化每个num的右边界为自己
        for (int num : nums) {
            map.put(num, num);
        }

        int ans = 0;
        for (int num : nums) {
            int right = map.get(num);
            // 遍历得到最远的右边界
            while (map.containsKey(right + 1)) {
                right = map.get(right + 1);
            }
            // 更新右边界
            map.put(num, right);
            // 更新答案
            ans = Math.max(ans, right - num + 1);
        }
        return ans;
    }
}
```

双指针

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        int result=0,count=1;
        Arrays.sort(nums);
        int left=0,right=left+1;
        while(right<nums.length){
            if(nums[right]==nums[right-1]+1){
                count++;
                right++;
            }else if(nums[right]==nums[right-1]){
                right++;
            }else{
                result=Math.max(result,count);
                left=right;
                right++;
                count=1;
            }
        }
        result=Math.max(result,count);
        return result;
    }   
}
```

#### [253. 会议室 II](https://leetcode-cn.com/problems/meeting-rooms-ii/)

![image-20220124084433520](14%20%E9%AB%98%E9%A2%91.assets/image-20220124084433520.png)

https://www.bilibili.com/video/BV1Ba4y177Pe/ 

![image-20220124100258907](14%20%E9%AB%98%E9%A2%91.assets/image-20220124100258907.png)

按照开始时间sort一下

使用min pq来track **ending time**, 来存最早结束时间!!! 方便知道什么时候meeting room可用

然后看看新的meeting的开始时间是否和上一个区间的结束时间冲突, 

1. 如果下一区间开始时间 >= pq里取出来的结束时间(说明这个房间可以再次利用), 那么pq就要poll()出来这个时间,再加入这个新区间的结束时间到pq(即开一个新房间). 

2. 如果下一区间开始时间 < pq里取出来的结束时间(即老房间还没结束会议), 添加新房间, 加入这个新区间的结束时间到pq.  

```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        //按照开始时间sort一下
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if (o1 == o2) {
                    return 0;
                }
                return o1[0] > o2[0] ? 1 : -1; //小的在前面
            }
        });
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(intervals.length, new Comparator<Integer>() {
            @Override
            public int compare(Integer a, Integer b) {
                if (a == b) {
                    return 0;
                }
                return a > b ? 1 : -1; //实现minHeap
            }
        });
        minHeap.add(intervals[0][1]);
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] >= minHeap.peek()) {
                //如果开始时间比之前的结束时间要大，说明这个房间可以利用，那么就要poll()出来老房间的结束时间, 后面再更新pq该房间的结束时间
                minHeap.poll();
            }
            minHeap.add(intervals[i][1]); //开辟新的房间，即minHeap中添加结束时间 或者不添加房间只是更新结束时间
        }
        return minHeap.size();
    }
}
```

#### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

错位相加

![image-20220203171449824](14%20%E9%AB%98%E9%A2%91.assets/image-20220203171449824.png)

![image-20220203171918781](14%20%E9%AB%98%E9%A2%91.assets/image-20220203171918781.png)

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        if (numRows < 1) return new ArrayList<>();
        List<List<Integer>> ans = new ArrayList<>();
        ans.add(new ArrayList<>(1));
        ans.get(0).add(1);
        for (int i = 1; i < numRows; i++) {
            Integer[] arr = new Integer[i + 1];
            arr[0] = arr[i] = 1;
            for (int x = 1; x < i; x++)
                arr[x] = ans.get(i - 1).get(x) + ans.get(i - 1).get(x - 1);
            ans.add(Arrays.asList(arr));
        }
        return ans;
    }
}
```



#### [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

![image-20220301105840631](14%20%E9%AB%98%E9%A2%91.assets/image-20220301105840631.png)

![image-20220301111242930](14%20%E9%AB%98%E9%A2%91.assets/image-20220301111242930.png)

![image-20220301111645448](14%20%E9%AB%98%E9%A2%91.assets/image-20220301111645448.png)

```java
public class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0, pre = 0;
        HashMap < Integer, Integer > mp = new HashMap <> ();
        mp.put(0, 1);
        for (int i = 0; i < nums.length; i++) {
            pre += nums[i];
            if (mp.containsKey(pre - k)) {
                count += mp.get(pre - k);
            }
            mp.put(pre, mp.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}
```

