# 11 2.27 显示登录信息
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021052923580637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JpY2hhcmQyMDE4MDM=,size_16,color_FFFFFF,t_70)

## 拦截器示例
能够拦截浏览器访问过来的请求，然后请求开始或结束的时候插入代码从而批量解决多个请求==共有的业务==，总之**低耦合**解决通用问题

由于它处理的是请求，属于表现层的逻辑，于是把它放到controller里interceptor包里

定义拦截器，实现HandlerInterceptor

```java
@Component
public class AlphaInterceptor implements HandlerInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(AlphaInterceptor.class);

    // 在拦截请求时，在Controller之前执行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        logger.debug("preHandle: " + handler.toString());
        return true;
    }

    // 在Controller之后执行，返回给模板引擎 modelAndView用来装一些参数
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        logger.debug("postHandle: " + handler.toString());
    }

    // 在TemplateEngine之后执行
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        logger.debug("afterCompletion: " + handler.toString());
    }
}

```
- 配置拦截器，为它指定拦截、排除的路径, 在config下写

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private AlphaInterceptor alphaInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(alphaInterceptor)
                .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg")
                .addPathPatterns("/register", "/login"); //排除一些路径，即一些静态资源。然后明确需要拦截的路径/register等
    }
}
```
- 测试
打开 http://localhost:8080/community/login
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210530003339825.png)
但是看不出来是否在controller之前还是之后，搞断点

在这里插入图片描述
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210530004129345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JpY2hhcmQyMDE4MDM=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210530004053430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JpY2hhcmQyMDE4MDM=,size_16,color_FFFFFF,t_70)
然后打开浏览器刷新
先卡到preHandle
F9 卡到login
再F9就到posthandle
## 拦截器应用
假设用户已经登录，然后就存了一个cookie ticket。然后浏览器再一次访问就会把cookie发给服务器，服务器就能得到ticket，这个ticket关联的就是客服，然后就可以查login_ticket来查到用户，然后再查user表即可。得到user信息之后就运用到模板上，把它放到model里面。template就会返回一个html，包含用户的登录信息。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210530005523480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JpY2hhcmQyMDE4MDM=,size_16,color_FFFFFF,t_70)
在请求开始时查询登录用户
在本次请求中持有用户数据
在模板视图上显示用户数据
在请求结束时清理用户数据

把数据存到一个地方，让**多线程并发**没有问题，得考虑线程的**隔离**，每一个线程单独存一份，互相之间不干扰。有一个工具就是ThreadLocal里。这个逻辑就最好封装成一个小的工具。在util包下，新建hostholder
- 以线程为key来存取值的逻辑
```java
/**
 * 持有用户信息（容器作用）,用于代替session对象.
 */
@Component
public class HostHolder {

    private ThreadLocal<User> users = new ThreadLocal<>();

    public void setUser(User user) {
        users.set(user);
    }

    public User getUser() {
        return users.get();
    }

    public void clear() {
        users.remove();
    } //请求结束的时候防止占用太多内存

}
```
- 拦截器

```java
@Component
public class LoginTicketInterceptor implements HandlerInterceptor {
    @Autowired
    private UserService userService;

    @Autowired
    private HostHolder hostHolder;

    /**
     * 一开始就要获取ticket 从而利用它查找有没有对应的user 然后暂存到线程对应的对象hostHolder
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 第一步： 从cookie中获取凭证
        String ticket = CookieUtil.getValue(request, "ticket");

        if (ticket != null) {
            // 查询凭证
            LoginTicket loginTicket = userService.findLoginTicket(ticket);
            // 检查凭证是否有效 loginTicket.getStatus() == 0 有效的
            if (loginTicket != null && loginTicket.getStatus() == 0 && loginTicket.getExpired().after(new Date())) {
                // 根据凭证查询用户
                User user = userService.findUserById(loginTicket.getUserId());
                // 查到后在模板里用 在本次请求中持有用户 需要暂存一下
                hostHolder.setUser(user);
            }
        }

        return true;
    }

    /**
     * 在模板引擎之前就要用user，应该把user存到model里 所以重写postHandle，在模板之前调用
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        User user = hostHolder.getUser();
        if (user != null && modelAndView != null) {
            modelAndView.addObject("loginUser", user);
        }
    }

    /**
     * 然后清理数据
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        hostHolder.clear();
    }
}
```
在userService里面写一下查询ticket方法

```java
    /**
     * 查询凭证的方法
     * @param ticket
     * @return
     */
    public LoginTicket findLoginTicket(String ticket) {
        return loginTicketMapper.selectByTicket(ticket);
    }
```

拦截器写完之后就配置

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private AlphaInterceptor alphaInterceptor;

    @Autowired
    private LoginTicketInterceptor loginTicketInterceptor;
     @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(alphaInterceptor)
                .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg")
                .addPathPatterns("/register", "/login"); //排除一些路径，即一些静态资源。然后明确需要拦截的路径/register等

        registry.addInterceptor(loginTicketInterceptor)
                .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");
    }

}
```

然后到模板处理
<li class="nav-item ml-3 btn-group-vertical" th:if="${loginUser!=null}">
<li class="nav-item ml-3 btn-group-vertical dropdown" th:if="${loginUser!=null}">
<span class="dropdown-item text-center text-secondary" th:utext="${loginUser.username}">nowcoder</span>
然后页面上显示没有登录时候菜单栏是如下所示
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210530020600125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JpY2hhcmQyMDE4MDM=,size_16,color_FFFFFF,t_70)
登录以后
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210530020722808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JpY2hhcmQyMDE4MDM=,size_16,color_FFFFFF,t_70)