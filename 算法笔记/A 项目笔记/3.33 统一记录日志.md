# 统一记录日志
不发生异常也要记录，拦截器是针对控制器的处理，记日志可能是数据访问或者业务组件。记录日志是系统需求。解决的好办法，系统需求拆分出去。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611020233543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JpY2hhcmQyMDE4MDM=,size_16,color_FFFFFF,t_70)

## AOP的概念
- **Aspect** Oriented Programing，
即面向方面（切面）编程。
- AOP是一c种编程思想，是对OOP的补充，可以进一步提高编程的效率。
- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611020313495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JpY2hhcmQyMDE4MDM=,size_16,color_FFFFFF,t_70)

一个组件独立出来统一管理多个模块的日志，相当于切了一刀。

## AOP的术语

Joinpoint: 目标对象上被植入代码的位置
Traget: 已经开发好了处理好业务逻辑的bean称为目标对象
Pointcut : 声明切点，被织入对象的位置
Advice：具体的系统逻辑，具体的位置，成员方法的抛异常位置等等
AOP解决统一处理系统需求的方式是将代码定**义到一个额外的bean, Aspect组件里**，这个主键利用框架，将这个业务组件的需求织入到target模块中。 不同的框架采用不同的实现方式下面的三种。 



![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611020353123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JpY2hhcmQyMDE4MDM=,size_16,color_FFFFFF,t_70)

## AOP的实现
- AspectJ
AspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法。
AspectJ在编译期织入代码，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。
- Spring AOP
Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器。
Spring AOP在`运行时`通过`代理`的方式织入代码，只支持`方法类型`的连接点。
Spring支持对AspectJ的集成。

## Spring AOP
- **JDK动态代理**
Java提供的动态代理技术，可以在运行时创建接口的代理实例。
 Spring AOP默认采用此种方式，在接口的代理实例中织入代码。
- **CGLib动态代理** (第三方) 用这个
采用底层的字节码技术，在运行时创建子类代理实例。
当目标对象`不存在接口`时，Spring AOP会采用此种方式，在子类实例中织入代码。

```java
//@Component
//@Aspect
public class AlphaAspect {

    @Pointcut("execution(* com.nowcoder.community.service.*.*(..))")
    public void pointcut() { //定义切点，加上注解 第一个*表示任何返回值，然后写上包名，所有的方法，（..）所有参数和返回值

    }

    @Before("pointcut()")
    public void before() { //定义通知，在切点的开始
        System.out.println("before");
    }

    @After("pointcut()")
    public void after() {//定义通知，在切点的结束
        System.out.println("after");
    }

    @AfterReturning("pointcut()")
    public void afterRetuning() { //有了返回值以后处理逻辑
        System.out.println("afterRetuning");
    }

    @AfterThrowing("pointcut()")
    public void afterThrowing() { //抛异常的时候植入代码
        System.out.println("afterThrowing");
    }

    @Around("pointcut()")  //前后都织入逻辑
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable { //前后都植入逻辑
        System.out.println("around before");
        Object obj = joinPoint.proceed(); //程序执行的时候会执行代理对象，这个逻辑会到代理对象里代替原始对象
        System.out.println("around after");
        return obj;
    }

}

```java
@Component
@Aspect
public class ServiceLogAspect {

    private static final Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class); //记日志实例化logger

    @Pointcut("execution(* com.nowcoder.community.service.*.*(..))")
    public void pointcut() {

    }

    @Before("pointcut()")
    public void before(JoinPoint joinPoint) { //一开始就织入
        // 用户[1.2.3.4],在[xx时间x],  访问了[com.nowcoder.community.service.xx功能x()].
        //RequestContextHolder中getRequestAttributes，转换成子类型。
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();//得到request对象
        String ip = request.getRemoteHost(n);
        String now = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
        String target = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName();
        logger.info(String.format("用户[%s],在[%s],访问了[%s].", ip, now, target));
    }

}
```